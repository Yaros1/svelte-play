(function(r,c){typeof exports=="object"&&typeof module<"u"?module.exports=c():typeof define=="function"&&define.amd?define(c):(r=typeof globalThis<"u"?globalThis:r||self,r.BComponent=c())})(this,function(){"use strict";var G=Object.defineProperty;var H=(r,c,f)=>c in r?G(r,c,{enumerable:!0,configurable:!0,writable:!0,value:f}):r[c]=f;var y=(r,c,f)=>H(r,typeof c!="symbol"?c+"":c,f);function r(){}function c(t){return t()}function f(){return Object.create(null)}function h(t){t.forEach(c)}function b(t){return typeof t=="function"}function j(t,e){return t!=t?e==e:t!==e||t&&typeof t=="object"||typeof t=="function"}function B(t){return Object.keys(t).length===0}function C(t,e,n){t.insertBefore(e,n||null)}function x(t){t.parentNode&&t.parentNode.removeChild(t)}function O(t){return document.createElement(t)}function S(t){return Array.from(t.childNodes)}let p;function a(t){p=t}const d=[],w=[];let u=[];const k=[];function g(t){u.push(t)}const $=new Set;let s=0;function N(){if(s!==0)return;const t=p;do{try{for(;s<d.length;){const e=d[s];s++,a(e),I(e.$$)}}catch(e){throw d.length=0,s=0,e}for(a(null),d.length=0,s=0;w.length;)w.pop()();for(let e=0;e<u.length;e+=1){const n=u[e];$.has(n)||($.add(n),n())}u.length=0}while(d.length);for(;k.length;)k.pop()();$.clear(),a(t)}function I(t){if(t.fragment!==null){t.update(),h(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(g)}}function T(t){const e=[],n=[];u.forEach(o=>t.indexOf(o)===-1?e.push(o):n.push(o)),n.forEach(o=>o()),u=e}const q=new Set;function A(t,e){t&&t.i&&(q.delete(t),t.i(e))}function L(t,e,n){const{fragment:o,after_update:l}=t.$$;o&&o.m(e,n),g(()=>{const _=t.$$.on_mount.map(c).filter(b);t.$$.on_destroy?t.$$.on_destroy.push(..._):h(_),t.$$.on_mount=[]}),l.forEach(g)}function M(t,e){const n=t.$$;n.fragment!==null&&(T(n.after_update),h(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function P(t,e,n,o,l,_,v=null,F=[-1]){const m=p;a(t);const i=t.$$={fragment:null,ctx:[],props:_,update:r,not_equal:l,bound:f(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(m?m.$$.context:[])),callbacks:f(),dirty:F,skip_bound:!1,root:e.target||m.$$.root};if(v&&v(i.root),i.ctx=[],i.update(),h(i.before_update),i.fragment=o?o(i.ctx):!1,e.target){if(e.hydrate){const E=S(e.target);i.fragment&&i.fragment.l(E),E.forEach(x)}else i.fragment&&i.fragment.c();e.intro&&A(t.$$.fragment),L(t,e.target,e.anchor),N()}a(m)}class R{constructor(){y(this,"$$");y(this,"$$set")}$destroy(){M(this,1),this.$destroy=r}$on(e,n){if(!b(n))return r;const o=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return o.push(n),()=>{const l=o.indexOf(n);l!==-1&&o.splice(l,1)}}$set(e){this.$$set&&!B(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const U="4";typeof window<"u"&&(window.__svelte||(window.__svelte={v:new Set})).v.add(U);function V(t){let e;return{c(){e=O("div"),e.textContent=`${z}`},m(n,o){C(n,e,o)},p:r,i:r,o:r,d(n){n&&x(e)}}}let z="B";class D extends R{constructor(e){super(),P(this,e,null,V,j,{})}}return D});
